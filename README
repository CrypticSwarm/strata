Link is a modular web server interface for Node.js. Using Link, web developers
can build highly performant servers in a powerful, modular style that encourages
readability and clean separation of responsibility. The core Link distribution
consists of three things:

  - A specification (see SPEC) for building applications and middleware
  - A library (see lib) with many useful utilities and middleware to aid
    developers in the common tasks of building applications that conform to
    the specification
  - An executable (see bin/linkup) for running Link applications from the
    command line

= Installation

Using npm:

  $ npm install link

You are also free to browse or download the source at
https://github.com/mjijackson/link.

= Features

  - Completely non-blocking architecture
  - Extensive test suite
  - Support for streaming responses to the client
  - Support for streaming multipart file uploads
  - Support for application/json (read JSON) requests
  - Session support via HTTP cookies
  - Unified error handling mechanism
  - Lint and mock modules for testing

= Usage

Link reduces the complex task of building a web application to the simplest
terms possible. A Link application is simply a JavaScript function that takes
two arguments: the environment and a callback. The environment is a JavaScript
object that contains information about the incoming request such as the request
method that was used, any parameters that were sent, etc. When the application
is ready to send the response to the client, it simply calls the callback with
three arguments: the response status code, the HTTP headers, and the body.

A simple Hello World app looks like this:

    function (env, callback) {
        callback(200, {
            "Content-Type": "text/plain",
            "Content-Length": "12"
        }, "Hello world!");
    }

== Request Parameters

Request parameters found in both the query string and request body may be
accessed easily using link.Request. The following sample app simply returns a
response that contains the parameters object in the body as JSON.

    var link = require("link");

    function (env, callback) {
        var req = new link.Request(env);

        req.params(function (err, params) {
            if (err && link.handleError(err, env, callback)) {
                return;
            }

            var content = JSON.stringify(params);

            callback(200, {
                "Content-Type": "application/json",
                "Content-Length": content.length.toString(10)
            }, content);
        });
    }

== Middleware

Because Link applications are built according to a specification, we know
exactly what parameters each expects to receive when it is called. This allows
us to build higher level abstractions called middleware that can easily be
inserted into and removed from the callback chain.

The pattern for building middleware typically looks something like this:

    function setUsername(app) {
        return function (env, callback) {
            // Modify the env for the "downstream" app...
            env["myapp.username"] = "Michael";

            // Call the app.
            app(env, callback);
        }
    }

This middleware can be used to wrap another Link application like this:

    var myApp = setUsername(function (env, callback) {
        // We know have access to the environment variable we
        // set in the "upstream" middleware.
        var username = env["myapp.username"];

        // Welcome them to our site.
        callback(200, {"Content-Type": "text/plain"}, "Welcome " + username);
    });

Using this technique you can built complex applications in a modular style, each
piece of which is easily testable.

Several useful middlewares come packaged in the Link core distribution. See
link.commonLogger, link.contentLength, and link.contentType for some examples.

== Errors

One of the typical pain points when building asynchronous applications is the
proper handling of errors that may occur somewhere in the callback chain. Link
takes a simple and flexible approach to error handling. You may have noticed in
the example above a call to link.handleError. This function takes three
arguments: the error, the environment, and the response callback.

The default error handler simply logs the error and calls the callback with a
500 Server Error response. Your application may override this function to
provide better error handling logic.

Link also includes a special constructor for errors that allows them to be
nested. Using this mechanism, higher level errors can keep a reference to the
lower level errors that caused them. This can be useful in a stack trace to see
detailed information about each level of the stack trace.

= Examples

A number of examples are included in the examples directory in the root of the
project source code. You can run any of these examples using the linkup command:

  $ ./bin/linkup examples/hello.js

= Tests

To run the tests, first install vows:

  $ npm install vows

Run all tests with:

  $ ./node_modules/.bin/vows test/*_test.js

Otherwise, run the tests for a specific module with:

  $ ./node_modules/.bin/vows test/utils_test.js

= Credits

Link was inspired by similar efforts in the Python and Ruby communities, namely
WSGI and Rack. It borrows many code patterns from these libraries, as well as
the JSGI project. Link's multipart parser is based on the fast parser in the
node-formidable project.

My sincere thanks to the authors of each of these libraries for the excellent
work they've done and graciously shared.
